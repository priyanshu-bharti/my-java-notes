# Topics to Cover

1. ~~Data Types (Primitives and Reference)~~
2. Shallow vs Deep Copying
3. Wrapper Types
4. Collection Framework
   1. Arrays
   2. String
   3. ArrayList
   4. HashSet
   5. HashMap
   6. Stack
   7. PriorityQueue
   8. ArrayDeque
   9. Records

# Data Types

## Primitives (Stored in Stack)

- Primitive types in Java are the most basic data types that store simple values directly in memory.
- They are faster than objects and have default values if not initialized explicitly.

### byte (8-bit)

- Range: -128 to 127 (2^7 to 2^7 - 1)
- Used to save memory when dealing with large arrays.
- Example: byte b = 100;

### short (16-bit)

- Range: -32,768 to 32,767 (-2^15 to 2^15 - 1)
- Slightly larger than byte, but still useful for memory-efficient programs.
- Example: short s = 10000;

### int (32-bit)

- Range: -2,147,483,648 to 2,147,483,647 (-2^31 to 2^31 - 1)
- Default choice for integer-based calculations unless memory optimization is required.
- Example: int i = 100000000;

### long (64-bit)

- Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (-2^63 to 2^63 - 1)
- Requires an L suffix when assigning large values (100000000000L).
- Example: long l = 100000000000L;

### float (32-bit, IEEE 754)

- Range: Approx ±3.4 × 10⁻³⁸ to ±3.4 × 10³⁸
- Less precise than double, requires an f suffix (1.42f).
- Good for applications where high precision isn't required (e.g., graphics, physics simulations).
- Example: float f = 1.42f;

### double (64-bit, IEEE 754)

- Range: Approx ±1.7 × 10⁻³⁰⁸ to ±1.7 × 10³⁰⁸
- More precise than float, used for scientific and mathematical calculations.
- Example: double d = 123.12345345233;

### char (16-bit)

- Stores a single character and uses Unicode (UTF-16 encoding).
- Example: char c = 'a';
- Unlike C, Java's char is not 8-bit; it’s 16-bit to support Unicode characters.

### boolean (1-bit, theoretically)

- Can only be true or false.
- Used for control flow and logical operations.
- Example: boolean t = true;
- Note: The exact memory usage isn't defined, but it's optimized by the JVM.

```java
import java.util.Arrays;

class Basics {
  public static void main(String[] args) {

    /* ----- Primitives ----- */

    // Bytes
    byte b = 100;
    System.out.println(b);

    // Short
    short s = 10000;
    System.out.println(s);

    // Int
    int i = 100000000;
    System.out.println(i);

    // Long
    long l = 100000000000L;
    System.out.println(l);

    // Float
    float f = 1.42f;
    System.out.println(f);

    // Double
    double d = 123.12345345233;
    System.out.println(d);

    // Char
    char c = 'a';
    System.out.println(c);

    // Boolean
    boolean t = true;
    System.out.println(t);

    /* ----- Non-Primitives ----- */

    // Strings
    String str = "Hello, World!";
    System.out.println(str);

    // Arrays
    int[] array = new int[5];
    System.out.println(Arrays.toString(array));

    // Enums
    enum Day {
      SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
    }
    Day day = Day.MONDAY;
    System.out.println(day);
  }
}

```

## Trivia about Data Types

1.  **Boolean** isn't always 1-bit in memory

    - Java does not guarantee boolean is stored as a single bit.
    - The JVM stores boolean as an int (4 bytes) in arrays and as a byte (1 byte) in objects to optimize performance.
    - boolean[] is stored as a byte array (8x more memory than necessary!).
    - Example: new boolean[1024] actually takes 1024 bytes instead of just 128 bits!

2.  **Char** is 16-bit (UTF-16) but still cannot store all Unicode characters

    - Unicode characters outside the Basic Multilingual Plane (BMP)
    - (e.g., emoji, some Chinese/Japanese symbols) need two chars (called "surrogate pairs").
    - You can write emojis in strings but not in char.

3.  **byte** is signed, unlike in C and C++

    - In Java, byte can’t store values above 127.
    - There is no unsigned byte in Java (though you can simulate it using int).

4.  **Strings** are stored in a String Pool, but it has limits

    - You can force a string to not be interned using new keyword.

    ```java
     String a = "Hello";
     String b = new String("Hello");
     System.out.println(a == b); // false (different memory locations)
    ```

5.  **Enums** can have constructors, methods, and fields

    - This can be used when you wanna assign some values to the enum itself.

    ```java
    enum Day {
      SUNDAY("sun"), MONDAY("mon"), TUESDAY("tue"), WEDNESDAY("wed"), THURSDAY("thu"), FRIDAY("fri"), SATURDAY("sat");

    // Declare a field
    private String day;

    // Create a constructor
    Day(String day) {
    this.day = day;
    }

    // Getter
    public String getDay() {
    return this.day;
    }
    }
    Day day = Day.MONDAY;

    System.out.println(day); // MONDAY
    System.out.println(day.getDay()); // mon
    ```

6.  **Enums** are actually final and static, but not abstract

7.  **Runnable** can be used without creating a thread

    - Runnable doesn't start a new thread itself.
    - If you just create a runnable without passing it to a thread, it'll run in the main thread.

    ```java
    Runnable task = () -> System.out.println("Hello");
    task.run(); // Runs in the main thread
    ```

8.  **Array** length is a field, not a method, but String.length() is a method.

9.  **Arrays** are actually objects, not primitives

    - Length is a field and not a method.
    - In Java, an int[] array is an object with clone() and hashCode() methods.
