# Topics Covered (Click to Jump)

1. ~~[Data Types (Primitives and Reference)](#data-types)~~
2. ~~[Shallow vs Deep Copying](#shallow-vs-deep-copying)~~
3. [Wrapper Types](#wrapper-types)
4. [Collection Framework](#collection-framework-methods)
   1. [Arrays](#arrays)
   2. [String](#string)
   3. [ArrayList](#arraylist)
   4. [HashSet](#hashset)
   5. [HashMap](#hashmap)
   6. [Stack](#stack)
   7. [PriorityQueue](#priorityqueue)
   8. [ArrayDeque](#arraydeque)
   9. [Records](#records)

# Data Types

## Primitives (Stored in Stack)

- Primitive types in Java are the most basic data types that store simple values directly in memory.
- They are faster than objects and have default values if not initialized explicitly.

### byte (8-bit)

- Range: -128 to 127 (2^7 to 2^7 - 1)
- Used to save memory when dealing with large arrays.
- Example: byte b = 100;

### short (16-bit)

- Range: -32,768 to 32,767 (-2^15 to 2^15 - 1)
- Slightly larger than byte, but still useful for memory-efficient programs.
- Example: short s = 10000;

### int (32-bit)

- Range: -2,147,483,648 to 2,147,483,647 (-2^31 to 2^31 - 1)
- Default choice for integer-based calculations unless memory optimization is required.
- Example: int i = 100000000;

### long (64-bit)

- Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (-2^63 to 2^63 - 1)
- Requires an L suffix when assigning large values (100000000000L).
- Example: long l = 100000000000L;

### float (32-bit, IEEE 754)

- Range: Approx ±3.4 × 10⁻³⁸ to ±3.4 × 10³⁸
- Less precise than double, requires an f suffix (1.42f).
- Good for applications where high precision isn't required (e.g., graphics, physics simulations).
- Example: float f = 1.42f;

### double (64-bit, IEEE 754)

- Range: Approx ±1.7 × 10⁻³⁰⁸ to ±1.7 × 10³⁰⁸
- More precise than float, used for scientific and mathematical calculations.
- Example: double d = 123.12345345233;

### char (16-bit)

- Stores a single character and uses Unicode (UTF-16 encoding).
- Example: char c = 'a';
- Unlike C, Java's char is not 8-bit; it’s 16-bit to support Unicode characters.

### boolean (1-bit, theoretically)

- Can only be true or false.
- Used for control flow and logical operations.
- Example: boolean t = true;
- Note: The exact memory usage isn't defined, but it's optimized by the JVM.

```java
import java.util.Arrays;

class Basics {
  public static void main(String[] args) {

    /* ----- Primitives ----- */

    // Bytes
    byte b = 100;
    System.out.println(b);

    // Short
    short s = 10000;
    System.out.println(s);

    // Int
    int i = 100000000;
    System.out.println(i);

    // Long
    long l = 100000000000L;
    System.out.println(l);

    // Float
    float f = 1.42f;
    System.out.println(f);

    // Double
    double d = 123.12345345233;
    System.out.println(d);

    // Char
    char c = 'a';
    System.out.println(c);

    // Boolean
    boolean t = true;
    System.out.println(t);

    /* ----- Non-Primitives ----- */

    // Strings
    String str = "Hello, World!";
    System.out.println(str);

    // Arrays
    int[] array = new int[5];
    System.out.println(Arrays.toString(array));

    // Enums
    enum Day {
      SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
    }
    Day day = Day.MONDAY;
    System.out.println(day);
  }
}

```

## Trivia about Data Types

1.  **Boolean** isn't always 1-bit in memory

    - Java does not guarantee boolean is stored as a single bit.
    - The JVM stores boolean as an int (4 bytes) in arrays and as a byte (1 byte) in objects to optimize performance.
    - boolean[] is stored as a byte array (8x more memory than necessary!).
    - Example: new boolean[1024] actually takes 1024 bytes instead of just 128 bits!

2.  **Char** is 16-bit (UTF-16) but still cannot store all Unicode characters

    - Unicode characters outside the Basic Multilingual Plane (BMP)
    - (e.g., emoji, some Chinese/Japanese symbols) need two chars (called "surrogate pairs").
    - You can write emojis in strings but not in char.

3.  **byte** is signed, unlike in C and C++

    - In Java, byte can’t store values above 127.
    - There is no unsigned byte in Java (though you can simulate it using int).

4.  **Strings** are stored in a String Pool, but it has limits

    - You can force a string to not be interned using new keyword.

    ```java
     String a = "Hello";
     String b = new String("Hello");
     System.out.println(a == b); // false (different memory locations)
    ```

5.  **Enums** can have constructors, methods, and fields

    - This can be used when you wanna assign some values to the enum itself.

    ```java
    enum Day {
      SUNDAY("sun"), MONDAY("mon"), TUESDAY("tue"), WEDNESDAY("wed"), THURSDAY("thu"), FRIDAY("fri"), SATURDAY("sat");

    // Declare a field
    private String day;

    // Create a constructor
    Day(String day) {
    this.day = day;
    }

    // Getter
    public String getDay() {
    return this.day;
    }
    }
    Day day = Day.MONDAY;

    System.out.println(day); // MONDAY
    System.out.println(day.getDay()); // mon
    ```

6.  **Enums** are actually final and static, but not abstract

7.  **Runnable** can be used without creating a thread

    - Runnable doesn't start a new thread itself.
    - If you just create a runnable without passing it to a thread, it'll run in the main thread.

    ```java
    Runnable task = () -> System.out.println("Hello");
    task.run(); // Runs in the main thread
    ```

8.  **Array** length is a field, not a method, but String.length() is a method.

9.  **Arrays** are actually objects, not primitives

    - Length is a field and not a method.
    - In Java, an int[] array is an object with clone() and hashCode() methods.

# Shallow vs Deep Copying

- For copying an object we can use the copy constructor for either shallow or deep copying.
- For copying a list of primitives, we can either use Arrays.copyOf (for primitive arrays) or clone() methods in the collections.

```java
class Address {
  String city;

  Address(String city) {
    this.city = city;
  }

  // Copy Constructor
  Address(Address otherAddress) {
    this.city = otherAddress.city;
  }

  @Override
  public String toString() {
    return "Address [city=" + city + "]";
  }

}

class Person {
  String name;
  Address address;

  Person(String name, Address address) {
    this.name = name;
    this.address = address;
  }

  // Copy Constructor (Shallow)
  Person(Person otherPerson) {
  this.name = otherPerson.name;
  this.address = otherPerson.address; // This is just a reference
  }

  // Copy Constructor (Deep)
  Person(Person otherPerson) {
    this.name = otherPerson.name;
    this.address = new Address(otherPerson.address);
  }

  @Override
  public String toString() {
    return "Person [name=" + name + ", address=" + address + "]";
  }

}

class Basics {
  public static void main(String[] args) {
    Address ap1 = new Address("Bhopal");
    Address ap2 = new Address("Gurgaon");

    Person p1 = new Person("Priyanshu", ap1);
    Person p2 = new Person(p1);

    p2.name = "Something";
    p2.address = ap2;

    System.out.println(p1); // name=Priyanshu, address=Address [city=Bhopal]
    System.out.println(p2); // name=Something, address=Address [city=Gurgaon]
  }
}

```

# Wrapper Types

- Object representations of primitive data types.
- They are part of the java.lang package and provide utility methods for working with primitive values.
- You should generally use them unless performance is absolutely necessary.
- Java Automatically boxes and unboxes the values between primitives and wrapper types.
- Usecases:
  - When using collections
  - When using generics
  - When using Streaming and Functional Programming
  - When using Reflection API
  - When Dealing with Nullability
  - When Interacting with APIs which require Objects.

| Primitive Type | Wrapper Type |
| -------------- | ------------ |
| byte           | Byte         |
| short          | Short        |
| int            | Integer      |
| long           | Long         |
| float          | Float        |
| double         | Double       |
| char           | Character    |
| boolean        | Boolean      |

## Trivia about Wrapper Types

| Fact                                | Explanation                                                                                                                                                   |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Integer caching                     | Bytes -128 to 127 are cached since the values are small, others are not.                                                                                      |
| new Integer(n) creates new objects  | When using `new Integer(n)`, caching does NOT apply. Use `Integer.valueOf(n)` instead.                                                                        |
| Wrapper types can be null           | Risk: Wrapper types can be null, which may cause `NullPointerException` (NPE). Can cause `NullPointerException`.                                              |
| Autoboxing is slow                  | Adds memory and CPU overhead.                                                                                                                                 |
| Wrapper classes are immutable       | Once assigned, you cannot change the value of a wrapper object. Operations create new objects.                                                                |
| Double.NaN != Double.NaN            | `NaN` (Not a Number) is a special floating-point value. Use `Double.isNaN()` instead.                                                                         |
| parseInt() vs valueOf()             | `Integer.parseInt("123")` returns int (primitive). `Integer.valueOf("123")` returns Integer (wrapper). `parseInt()` returns int, `valueOf()` returns Integer. |
| == vs .equals()                     | `==` compares memory, `.equals()` compares values.                                                                                                            |
| Wrapper classes have useful methods | Like `bitCount()`, `toBinaryString()`.                                                                                                                        |
| int[] is not Integer[]              | Needs manual conversion with `boxed()`.                                                                                                                       |

## Wrapper Type Methods

### Byte

### Short

### Integer

### Long

### Float

### Double

### Character

### Boolean

# Collection Framework Methods

## Arrays

```java
import java.util.Arrays;

// Sorting
Arrays.sort(array);

// Reverse order sort (Requires wrapper types like Integer not int)
Arrays.sort(array, Collections.reverseOrder());

// Binary search (array must be sorted)
int index = Arrays.binarySearch(array, 3);

// Fill an array with a specific value
Arrays.fill(array, 10);

// Check if two arrays are equal
boolean isEqual = Arrays.equals(array1, array2);

// Convert array to string
String arrayString = Arrays.toString(array);

// Copy an array
int[] copiedArray = Arrays.copyOf(array, array.length); // Trunc/Pad

// Copy a range of an array
int[] rangeCopy = Arrays.copyOfRange(array, 1, 3); // From, to
```

## String

```java
// ------------- String Declarations -------------

// Using String Literals
String str1 = "Hello, World!";

// Using new Keyword
String str2 = new String("Hello, World!");

// Using Char Arrays
char[] charArray = {'H', 'e', 'l', 'l', 'o'};
String str3 = new String(charArray);

// StringBuilder or StringBuffer
StringBuilder sb = new StringBuilder("Hello");
sb.append(", World!");
String str4 = sb.toString();


// ----- Basic Methods -----

// Returns the length of string
int length = str.length();

// Get the character at given index
char ch = str.charAt(0);

// Check string == "" is an empty string
boolean isEmpty = str.isEmpty();

// Check string is empty only has spaces and no other chars.
boolean isBlank = str.isBlank();

// Check if 2 strings are equal - case sensitive
boolean equals = str.equals("Hello, World!");

// Check if 2 strings are equal - case insensitive
boolean equalsIgnoreCase = str.equalsIgnoreCase("hello, world!");

// Slice the string (start, end)
String substring = str.substring(7, 2);


// ----- Searching and Indexing -----

// Get the index of the given character
int indexOf = str.indexOf('o');

// Get the last index of the given character
int lastIndexOf = str.lastIndexOf('o');

// Check if the substring is present in the string
boolean contains = str.contains("World");


// ----- String Manipulation -----

// Convert into uppercase
String upperCase = str.toUpperCase();

// Convert into lowercase
String lowerCase = str.toLowerCase();

// Remove whitespaces from the start and the end
String trimmed = str.trim();

// Replace all the occurrences of a character
String replaced = str.replace('o', 'a');

// Replace all the occurrences of a regex string with another string
String replaced = str.replaceFirst("o", "a"); // Replace first

// Replace the 1st occurrence of a regex string with another string
String replaced = str.replaceFirst("o", "a"); // Replace first

// Split the string using a delimiter.
String[] split = str.split(", ");


// ----- String Comparison -----

// Compare the strings alphabetically.
int comparison = str.compareTo("Hello, World!");

// Compare the strings in case insensitive way.
int comparisonIgnoreCase = str.compareToIgnoreCase("hello, world!");


// ----- Joining Strings -----

// Join various strings together.
String joined = String.join(", ", "Hello", "World", "Java");
```

## ArrayList

```java
// Converting an array into array list
ArrayList<Integer> list = (ArrayList<Integer>) Arrays.stream(arr).boxed().collect(Collectors.toList());

// Add item to the end of the list
list.add(13);

// Get the item at the specified index
list.get(0);

// Add items from the other list to this one.
list.addAll(list2);

// Add to the start of the list
list.addFirst(1);

// Add to the end of the list
list.addLast(2);

// Remove all the items from the list
list.clear();

// Get a shallow copy of the array (not its elements)
list.clone();

// Return true if the item is present in the array
list.contains(2);

// Check if 2 lists are equal
list.equals(list2);

// Check if the list is empty
list.isEmpty();

// Returns the number of items in the list
list.size();

// Trim the list size to match the number of items in the list
list.trimToSize();

// Check if the list contains any of the specified items
list.containsAll(Arrays.asList(1, 2, 3, 4, 5));

// Check if any of the items match the condition
Boolean result = list.stream().allMatch(item -> item % 2 == 0);

// Check if all the items match certain condition
Boolean result = list.stream().allMatch(item -> item % 2 == 0);

// Find the first occurrence of something
Optional<Integer> something = list.stream().filter(x -> x%3==0).findFirst();

// Find all the occurrences of something
list.stream().filter(i -> i % 2 == 1).collect(Collectors.toList())

// Filter the list by a specific condition
ArrayList<Integer> filteredList = new ArrayList<Integer>(list.stream().filter(x -> x % 2 == 0).toList());

// For Each
list.forEach(i -> System.out.print(Main.format(i)));

// Map the list and transform its output
list.stream().map(i -> format(i)).toList()

// Reduce the list to some value
list.stream().reduce((i, v) -> i + v).get()

// Convert a list into a HashSet
HashSet<Integer> set = (HashSet<Integer>) list.stream().collect(Collectors.toSet());
```

## HashSet

```java
// Add item to the set
set.add(7);

// Delete everything from the set
set.clear();

// Returns true if the item is present in the set.
set.contains(3);

// Returns true if the set is empty
set.isEmpty();

// Removes the specified value from the set.
set.remove(7);

// Convert the set into an array
set.stream().toList();

// Get the number of items in the set.
set.size();

// Add multiple items to set at once
set.addAll(Arrays.asList(999, 7, 8, 9));

// Check if multiple items are present in the set.
set.containsAll(Arrays.asList(1, 2, 3));

// Get the min value from the set
set.stream().min(Integer::compareTo).get();

// Get the max value from the set
set.stream().max(Integer::compareTo).get();

// Get the set as a sorted list
set.stream().sorted().toList();
```

## HashMap

```java
// Set the value for the key "1"
map.put(1, 1);

// Get the value for the key "1"
map.get(1);

// Check if the key is present in the map
map.containsKey(1);

// Check if the value is present in the map
map.containsValue(2);

// Check if the map is empty
map.isEmpty();

// Get the value of the key, or some default value if the key isn't present
map.getOrDefault(1, 1);

// Only add a key if its not present. If it is, then returns existing value.
map.putIfAbsent(1, 2);

// Remove the key from the map.
map.remove(1);

// Get all the keys as a set
map.keySet()
```

## Stack

```java
// Push item into the stack
stack.push(1);

// Pop from the top
stack.pop();

// Get the topmost item
stack.peek();

// Check if the stack is empty (could be of non-zero size)
stack.empty();

// Check if the stack is truly empty (size 0)
stack.isEmpty();

// Get the idx of the item from the top (1 to stack.size) or -1
stack.search(2);
```

## PriorityQueue

```java
import static java.util.Collections.reverseOrder;

// Create a queue with a compartor
PriorityQueue<Integer> queue = new PriorityQueue<>(reverseOrder());

// Add something to the priority queue
queue.offer(1);

// Get stuff out from the queue
queue.poll();

// Check if something exists in the queue
queue.contains(1);

// Get the topmost item from the queue without removing it.
queue.peek();
```

## ArrayDeque

```java
ArrayDeque<Integer> queue = new ArrayDeque<>(reverseOrder());

// Add something to the dequeue from the head
queue.offerFirst(1);

// Add something to the dequeue from the tail
queue.offerLast(2);

// Get stuff out from the queue from the head
queue.pollFirst();

// Get stuff out from the queue from the tail
queue.pollLast();

// Check if something exists in the queue
queue.contains(1);

// Get the head item from the queue without removing it.
queue.peekFirst();

// Get the tail item from the queue without removing it.
queue.peekLast();
```

## Records

```java
package com.priyanshu;

record Person(String name, int age, String email) {}

public class Main {
    public static void main(String[] args) {
        Person user = new Person("Priyanshu", 20, "priyanshu@gmail.com");
        System.out.printf("%s %d %s",user.name(), user.age(), user.email());
    }
}
```
